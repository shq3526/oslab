#include <riscv.h>
    #首先我们定义一个汇编宏 SAVE_ALL, 用来保存所有寄存器到栈顶（实际上把一个trapFrame结构体放到了栈顶）。

    .macro SAVE_ALL  #定义汇编宏

    csrw sscratch, sp  #保存原先的栈顶指针到sscratch，将 `sp` 的值赋值给 `sscratch`，即保存原先的栈顶指针到 `sscratch`。  

    addi sp, sp, -36 * REGBYTES  
    #REGBYTES是riscv.h定义的常量，表示一个寄存器占据几个字节
    #让栈顶指针向低地址空间延伸 36个寄存器的空间，可以放下一个trapFrame结构体。
    #除了32个通用寄存器，我们还要保存4个和中断有关的CSR

    #依次保存32个通用寄存器。但栈顶指针需要特殊处理。
    #因为我们想在trapFrame里保存分配36个REGBYTES之前的sp
    #也就是保存之前写到sscratch里的sp的值

    #我们可以看到，trapentry.S作用是一个"包装器"：它负责保存和恢复上下文，并把上下文包装成结构体，传递给真正的中断处理函数trap那里去。
    #在上面的代码中，我们看到最后一条指令是sret。这是一条特权指令，用于从S模式返回，完成从内核态到用户态的切换。
    #在执行sret之前，需要完成一些准备工作。首先，从trapframe中恢复用户程序的寄存器值（这由RESTORE_ALL宏完成），使得用户程序能够继续运行。
    #接着，根据中断或者异常的类型重新设置sepc，确保程序能够从正确的地址继续执行。对于系统调用，这通常是 ecall指令的下一条指令地址（即sepc + 4）；
    #对于中断，这是被中断打断的指令地址（即sepc）；对于进程切换，这是新进程的起始地址。然后，将sstatus.SPP设置为 0，表示要返回到 U 模式。
    #当准备工作完成后，会执行sret指令，根据sstatus.SPP的值（此时为 0）切换回 U 模式。
    #随后，恢复中断使能状态，将sstatus.SIE恢复为sstatus.SPIE的值。由于在 U 模式下总是使能中断，因此中断会重新开启。
    #接着，更新sstatus，将sstatus.SPIE设置为 1,sstatus.SPP设置为 0，为下一次中断做准备。
    #最后，将sepc的值赋给pc，并跳转回用户程序（sepc指向的地址）继续执行。
    #此时，系统已经安全地从 S 模式返回到 U 模式，用户程序继续执行。
    
    # save x registers
    STORE x0, 0*REGBYTES(sp)
    STORE x1, 1*REGBYTES(sp)
    STORE x3, 3*REGBYTES(sp)
    STORE x4, 4*REGBYTES(sp)
    STORE x5, 5*REGBYTES(sp)
    STORE x6, 6*REGBYTES(sp)
    STORE x7, 7*REGBYTES(sp)
    STORE x8, 8*REGBYTES(sp)
    STORE x9, 9*REGBYTES(sp)
    STORE x10, 10*REGBYTES(sp)
    STORE x11, 11*REGBYTES(sp)
    STORE x12, 12*REGBYTES(sp)
    STORE x13, 13*REGBYTES(sp)
    STORE x14, 14*REGBYTES(sp)
    STORE x15, 15*REGBYTES(sp)
    STORE x16, 16*REGBYTES(sp)
    STORE x17, 17*REGBYTES(sp)
    STORE x18, 18*REGBYTES(sp)
    STORE x19, 19*REGBYTES(sp)
    STORE x20, 20*REGBYTES(sp)
    STORE x21, 21*REGBYTES(sp)
    STORE x22, 22*REGBYTES(sp)
    STORE x23, 23*REGBYTES(sp)
    STORE x24, 24*REGBYTES(sp)
    STORE x25, 25*REGBYTES(sp)
    STORE x26, 26*REGBYTES(sp)
    STORE x27, 27*REGBYTES(sp)
    STORE x28, 28*REGBYTES(sp)
    STORE x29, 29*REGBYTES(sp)
    STORE x30, 30*REGBYTES(sp)
    STORE x31, 31*REGBYTES(sp)

    # get sr, epc, badvaddr, cause
    # Set sscratch register to 0, so that if a recursive exception
    # occurs, the exception vector knows it came from the kernel

    # RISCV不能直接从CSR写到内存, 需要csrr把CSR读取到通用寄存器，再从通用寄存器STORE到内存
    #将 `sscratch` 赋值给 `s0`，然后将 `sscratch` 置 0。s0 用来表示函数调用前栈顶的位置。
    #将 `sscratch` 置 0 的话如果产生递归异常，异常向量就会知道它来自于内核。  
    
    csrrw s0, sscratch, x0
    csrr s1, sstatus
    csrr s2, sepc
    csrr s3, sbadaddr
    csrr s4, scause

    STORE s0, 2*REGBYTES(sp)
    STORE s1, 32*REGBYTES(sp)
    STORE s2, 33*REGBYTES(sp)
    STORE s3, 34*REGBYTES(sp)
    STORE s4, 35*REGBYTES(sp)
    .endm  #汇编宏定义结束


    #然后是恢复上下文的汇编宏，恢复的顺序和当时保存的顺序反过来，先加载两个CSR, 再加载通用寄存器
    .macro RESTORE_ALL

    LOAD s1, 32*REGBYTES(sp)
    LOAD s2, 33*REGBYTES(sp)


    # 注意之前保存的几个CSR并不都需要恢复
    csrw sstatus, s1
    csrw sepc, s2

    # restore x registers
    # 恢复sp之外的通用寄存器，这时候还需要根据sp来确定其他寄存器数值保存的位置
    LOAD x1, 1*REGBYTES(sp)
    LOAD x3, 3*REGBYTES(sp)
    LOAD x4, 4*REGBYTES(sp)
    LOAD x5, 5*REGBYTES(sp)
    LOAD x6, 6*REGBYTES(sp)
    LOAD x7, 7*REGBYTES(sp)
    LOAD x8, 8*REGBYTES(sp)
    LOAD x9, 9*REGBYTES(sp)
    LOAD x10, 10*REGBYTES(sp)
    LOAD x11, 11*REGBYTES(sp)
    LOAD x12, 12*REGBYTES(sp)
    LOAD x13, 13*REGBYTES(sp)
    LOAD x14, 14*REGBYTES(sp)
    LOAD x15, 15*REGBYTES(sp)
    LOAD x16, 16*REGBYTES(sp)
    LOAD x17, 17*REGBYTES(sp)
    LOAD x18, 18*REGBYTES(sp)
    LOAD x19, 19*REGBYTES(sp)
    LOAD x20, 20*REGBYTES(sp)
    LOAD x21, 21*REGBYTES(sp)
    LOAD x22, 22*REGBYTES(sp)
    LOAD x23, 23*REGBYTES(sp)
    LOAD x24, 24*REGBYTES(sp)
    LOAD x25, 25*REGBYTES(sp)
    LOAD x26, 26*REGBYTES(sp)
    LOAD x27, 27*REGBYTES(sp)
    LOAD x28, 28*REGBYTES(sp)
    LOAD x29, 29*REGBYTES(sp)
    LOAD x30, 30*REGBYTES(sp)
    LOAD x31, 31*REGBYTES(sp)
    # restore sp last
    # 最后恢复sp
    LOAD x2, 2*REGBYTES(sp)
    .endm

    #真正的中断入口点
    .globl __alltraps
    .align(2)  #中断入口点 __alltraps必须四字节对齐
__alltraps:
    SAVE_ALL   #保存上下文

    move  a0, sp  #传递参数:指向刚刚在栈上保存好的 trapframe 的指针
    #按照RISCV calling convention, a0寄存器传递参数给接下来调用的函数trap。
    #trap是trap.c里面的一个C语言函数，也就是我们的中断处理程序
    jal trap
    # sp should be the same as before "jal trap"
    #trap函数指向完之后，会回到这里向下继续执行__trapret里面的内容，RESTORE_ALL,sret

    .globl __trapret
__trapret:
    RESTORE_ALL
    # return from supervisor call
    sret
